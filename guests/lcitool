#!/usr/bin/env python

# lcitool - libvirt CI guest management tool
# Copyright (C) 2017-2018  Andrea Bolognani <abologna@redhat.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

import argparse
import crypt
import fnmatch
import os
import random
import string
import subprocess
import sys
import textwrap
import yaml

# This is necessary to maintain Python 2.7 compatibility
try:
    import configparser
except ImportError:
    import ConfigParser as configparser


class Error(Exception):

    def __init__(self, message):
        super(Error, self).__init__()
        self.message = message


class Util:

    @staticmethod
    def mksalt():
        alphabeth = string.ascii_letters + string.digits
        salt = "".join(random.choice(alphabeth) for x in range(0, 16))
        return "$6${}$".format(salt)

    @staticmethod
    def expand_pattern(pattern, source, name):
        if pattern is None:
            raise Error("Missing {} list".format(name))

        if pattern == "all":
            pattern = "*"

        # This works correctly for single items as well as more complex
        # cases such as explicit lists, glob patterns and any combination
        # of the above
        matches = []
        for partial_pattern in pattern.split(","):

            partial_matches = []
            for item in source:
                if fnmatch.fnmatch(item, partial_pattern):
                    partial_matches += [item]

            if not partial_matches:
                raise Error("Invalid {} list '{}'".format(name, pattern))

            matches += partial_matches

        return sorted(set(matches))


class Config:

    @staticmethod
    def _get_config_file(name):
        try:
            config_dir = os.environ["XDG_CONFIG_HOME"]
        except KeyError:
            config_dir = os.path.join(os.environ["HOME"], ".config/")
        config_dir = os.path.join(config_dir, "lcitool/")

        # Create the directory if it doesn't already exist
        if not os.path.exists(config_dir):
            try:
                os.mkdir(config_dir)
            except Exception:
                raise Error(
                    "Can't create configuration directory ({})".format(
                        config_dir,
                    )
                )

        return os.path.join(config_dir, name)

    def get_flavor(self):
        flavor_file = self._get_config_file("flavor")

        try:
            with open(flavor_file, "r") as infile:
                flavor = infile.readline().strip()
        except Exception:
            # If the flavor has not been configured, we choose the default
            # and store it on disk to ensure consistent behavior from now on
            flavor = "test"
            try:
                with open(flavor_file, "w") as infile:
                    infile.write("{}\n".format(flavor))
            except Exception:
                raise Error(
                    "Can't write flavor file ({})".format(
                        flavor_file,
                    )
                )

        if flavor not in ["test", "jenkins"]:
            raise Error("Invalid flavor '{}'".format(flavor))

        return flavor

    def get_vault_password_file(self):
        vault_pass_file = None

        # The vault password is only needed for the jenkins flavor, but in
        # that case we want to make sure there's *something* in there
        if self.get_flavor() != "test":
            vault_pass_file = self._get_config_file("vault-password")

            try:
                with open(vault_pass_file, "r") as infile:
                    if not infile.readline().strip():
                        raise ValueError
            except Exception:
                raise Error(
                    "Missing or invalid vault password file ({})".format(
                        vault_pass_file,
                    )
                )

        return vault_pass_file

    def get_root_password_file(self):
        root_pass_file = self._get_config_file("root-password")
        root_hash_file = self._get_config_file(".root-password.hash")

        try:
            with open(root_pass_file, "r") as infile:
                root_pass = infile.readline().strip()
        except Exception:
            raise Error(
                "Missing or invalid root password file ({})".format(
                    root_pass_file,
                )
            )

        # The hash will be different every time we run, but that doesn't
        # matter - it will still validate the correct root password
        root_hash = crypt.crypt(root_pass, Util.mksalt())

        try:
            with open(root_hash_file, "w") as infile:
                infile.write("{}\n".format(root_hash))
        except Exception:
            raise Error(
                "Can't write hashed root password file ({})".format(
                    root_hash_file,
                )
            )

        return root_hash_file


class Inventory:

    def __init__(self):
        try:
            parser = configparser.SafeConfigParser()
            parser.read("./ansible.cfg")
            inventory_path = parser.get("defaults", "inventory")
        except Exception:
            raise Error("Can't find inventory location in ansible.cfg")

        self._facts = {}
        try:
            # We can only deal with trivial inventories, but that's
            # all we need right now and we can expand support further
            # later on if necessary
            with open(inventory_path, "r") as infile:
                for line in infile:
                    host = line.strip()
                    self._facts[host] = {}
        except Exception:
            raise Error(
                "Missing or invalid inventory ({})".format(
                    inventory_path,
                )
            )

        for host in self._facts:
            try:
                self._facts[host] = self._read_all_facts(host)
                self._facts[host]["inventory_hostname"] = host
            except Exception:
                raise Error("Can't load facts for '{}'".format(host))

    @staticmethod
    def _add_facts_from_file(facts, yaml_path):
        with open(yaml_path, "r") as infile:
            some_facts = yaml.load(infile)
            for fact in some_facts:
                facts[fact] = some_facts[fact]

    def _read_all_facts(self, host):
        facts = {}

        # We load from group_vars/ first and host_vars/ second, sorting
        # files alphabetically; doing so should result in our view of
        # the facts matching Ansible's
        for source in ["./group_vars/all/", "./host_vars/{}/".format(host)]:
            for item in sorted(os.listdir(source)):
                yaml_path = os.path.join(source, item)
                if not os.path.isfile(yaml_path):
                    continue
                if not yaml_path.endswith(".yml"):
                    continue
                self._add_facts_from_file(facts, yaml_path)

        return facts

    def expand_pattern(self, pattern):
        return Util.expand_pattern(pattern, self._facts, "host")

    def get_facts(self, host):
        return self._facts[host]


class Application:

    def __init__(self):
        self._config = Config()
        self._inventory = Inventory()

        self._parser = argparse.ArgumentParser(
            conflict_handler="resolve",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description="libvirt CI guest management tool",
            epilog=textwrap.dedent("""
                common actions:
                  install  perform unattended host installation

                informational actions:
                  hosts  list all known hosts

                glob patterns are supported for HOSTS
            """),
        )
        self._parser.add_argument(
            "-a",
            metavar="ACTION",
            required=True,
            help="action to perform (see below)",
        )
        self._parser.add_argument(
            "-h",
            metavar="HOSTS",
            help="list of hosts to act on",
        )

    def _action_hosts(self, _hosts):
        for host in self._inventory.expand_pattern("all"):
            print(host)

    def _action_install(self, hosts):
        flavor = self._config.get_flavor()

        for host in self._inventory.expand_pattern(hosts):
            facts = self._inventory.get_facts(host)

            # Both memory size and disk size are stored as GiB in the
            # inventory, but virt-install expects the disk size in GiB
            # and the memory size in *MiB*, so perform conversion here
            memory_arg = str(int(facts["install_memory_size"]) * 1024)

            vcpus_arg = str(facts["install_vcpus"])

            disk_arg = "size={},pool={},bus=virtio".format(
                facts["install_disk_size"],
                facts["install_storage_pool"],
            )
            network_arg = "network={},model=virtio".format(
                facts["install_network"],
            )

            # preseed files must use a well-known name to be picked up by
            # d-i; for kickstart files, we can use whatever name we please
            # but we need to point anaconda in the right direction through
            # a kernel argument
            extra_arg = "console=ttyS0 ks=file:/{}".format(
                facts["install_config"],
            )

            cmd = [
                "virt-install",
                "--name", host,
                "--location", facts["install_url"],
                "--virt-type", facts["install_virt_type"],
                "--arch", facts["install_arch"],
                "--machine", facts["install_machine"],
                "--cpu", facts["install_cpu_model"],
                "--vcpus", vcpus_arg,
                "--memory", memory_arg,
                "--disk", disk_arg,
                "--network", network_arg,
                "--graphics", "none",
                "--console", "pty",
                "--sound", "none",
                "--initrd-inject", facts["install_config"],
                "--extra-args", extra_arg,
                "--wait", "0",
            ]

            # Only configure autostart for the guest for the jenkins flavor
            if flavor == "jenkins":
                cmd += ["--autostart"]

            try:
                subprocess.check_call(cmd)
            except Exception:
                raise Error("Failed to install '{}'".format(host))

    def run(self):
        cmdline = self._parser.parse_args()
        action = cmdline.a
        hosts = cmdline.h

        method = "_action_{}".format(action.replace("-", "_"))

        if hasattr(self, method):
            getattr(self, method).__call__(hosts)
        else:
            raise Error("Invalid action '{}'".format(action))


if __name__ == "__main__":
    try:
        Application().run()
    except Error as err:
        sys.stderr.write("{}: {}\n".format(sys.argv[0], err.message))
        sys.exit(1)
