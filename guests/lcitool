#!/usr/bin/env python

# lcitool - libvirt CI guest management tool
# Copyright (C) 2017-2018  Andrea Bolognani <abologna@redhat.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

import argparse
import crypt
import fnmatch
import os
import random
import string
import sys
import yaml

# This is necessary to maintain Python 2.7 compatibility
try:
    import configparser
except ImportError:
    import ConfigParser as configparser


class Error(Exception):

    def __init__(self, message):
        super(Error, self).__init__()
        self.message = message


class Util:

    @staticmethod
    def mksalt():
        alphabeth = string.ascii_letters + string.digits
        salt = "".join(random.choice(alphabeth) for x in range(0, 16))
        return "$6${}$".format(salt)

    @staticmethod
    def expand_pattern(pattern, source, name):
        if pattern is None:
            raise Error("Missing {} list".format(name))

        if pattern == "all":
            pattern = "*"

        # This works correctly for single items as well as more complex
        # cases such as explicit lists, glob patterns and any combination
        # of the above
        matches = []
        for partial_pattern in pattern.split(","):

            partial_matches = []
            for item in source:
                if fnmatch.fnmatch(item, partial_pattern):
                    partial_matches += [item]

            if not partial_matches:
                raise Error("Invalid {} list '{}'".format(name, pattern))

            matches += partial_matches

        return sorted(set(matches))


class Config:

    @staticmethod
    def _get_config_file(name):
        try:
            config_dir = os.environ["XDG_CONFIG_HOME"]
        except KeyError:
            config_dir = os.path.join(os.environ["HOME"], ".config/")
        config_dir = os.path.join(config_dir, "lcitool/")

        # Create the directory if it doesn't already exist
        if not os.path.exists(config_dir):
            try:
                os.mkdir(config_dir)
            except Exception:
                raise Error(
                    "Can't create configuration directory ({})".format(
                        config_dir,
                    )
                )

        return os.path.join(config_dir, name)

    def get_flavor(self):
        flavor_file = self._get_config_file("flavor")

        try:
            with open(flavor_file, "r") as infile:
                flavor = infile.readline().strip()
        except Exception:
            # If the flavor has not been configured, we choose the default
            # and store it on disk to ensure consistent behavior from now on
            flavor = "test"
            try:
                with open(flavor_file, "w") as infile:
                    infile.write("{}\n".format(flavor))
            except Exception:
                raise Error(
                    "Can't write flavor file ({})".format(
                        flavor_file,
                    )
                )

        if flavor not in ["test", "jenkins"]:
            raise Error("Invalid flavor '{}'".format(flavor))

        return flavor

    def get_vault_password_file(self):
        vault_pass_file = None

        # The vault password is only needed for the jenkins flavor, but in
        # that case we want to make sure there's *something* in there
        if self.get_flavor() != "test":
            vault_pass_file = self._get_config_file("vault-password")

            try:
                with open(vault_pass_file, "r") as infile:
                    if not infile.readline().strip():
                        raise ValueError
            except Exception:
                raise Error(
                    "Missing or invalid vault password file ({})".format(
                        vault_pass_file,
                    )
                )

        return vault_pass_file

    def get_root_password_file(self):
        root_pass_file = self._get_config_file("root-password")
        root_hash_file = self._get_config_file(".root-password.hash")

        try:
            with open(root_pass_file, "r") as infile:
                root_pass = infile.readline().strip()
        except Exception:
            raise Error(
                "Missing or invalid root password file ({})".format(
                    root_pass_file,
                )
            )

        # The hash will be different every time we run, but that doesn't
        # matter - it will still validate the correct root password
        root_hash = crypt.crypt(root_pass, Util.mksalt())

        try:
            with open(root_hash_file, "w") as infile:
                infile.write("{}\n".format(root_hash))
        except Exception:
            raise Error(
                "Can't write hashed root password file ({})".format(
                    root_hash_file,
                )
            )

        return root_hash_file


class Inventory:

    def __init__(self):
        try:
            parser = configparser.SafeConfigParser()
            parser.read("./ansible.cfg")
            inventory_path = parser.get("defaults", "inventory")
        except Exception:
            raise Error("Can't find inventory location in ansible.cfg")

        self._facts = {}
        try:
            # We can only deal with trivial inventories, but that's
            # all we need right now and we can expand support further
            # later on if necessary
            with open(inventory_path, "r") as infile:
                for line in infile:
                    host = line.strip()
                    self._facts[host] = {}
        except Exception:
            raise Error(
                "Missing or invalid inventory ({})".format(
                    inventory_path,
                )
            )

        for host in self._facts:
            try:
                self._facts[host] = self._read_all_facts(host)
                self._facts[host]["inventory_hostname"] = host
            except Exception:
                raise Error("Can't load facts for '{}'".format(host))

    @staticmethod
    def _add_facts_from_file(facts, yaml_path):
        with open(yaml_path, "r") as infile:
            some_facts = yaml.load(infile)
            for fact in some_facts:
                facts[fact] = some_facts[fact]

    def _read_all_facts(self, host):
        facts = {}

        # We load from group_vars/ first and host_vars/ second, sorting
        # files alphabetically; doing so should result in our view of
        # the facts matching Ansible's
        for source in ["./group_vars/all/", "./host_vars/{}/".format(host)]:
            for item in sorted(os.listdir(source)):
                yaml_path = os.path.join(source, item)
                if not os.path.isfile(yaml_path):
                    continue
                if not yaml_path.endswith(".yml"):
                    continue
                self._add_facts_from_file(facts, yaml_path)

        return facts

    def expand_pattern(self, pattern):
        return Util.expand_pattern(pattern, self._facts, "host")

    def get_facts(self, host):
        return self._facts[host]


class Application:

    def __init__(self):
        self._config = Config()
        self._inventory = Inventory()

        self._parser = argparse.ArgumentParser(
            description="libvirt CI guest management tool",
        )

    def run(self):
        self._parser.parse_args()


if __name__ == "__main__":
    try:
        Application().run()
    except Error as err:
        sys.stderr.write("{}: {}\n".format(sys.argv[0], err.message))
        sys.exit(1)
