#!/usr/bin/env python

# lcitool - libvirt CI guest management tool
# Copyright (C) 2017-2018  Andrea Bolognani <abologna@redhat.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

import argparse
import crypt
import fnmatch
import json
import os
import random
import string
import subprocess
import sys
import textwrap
import yaml

# This is necessary to maintain Python 2.7 compatibility
try:
    import configparser
except ImportError:
    import ConfigParser as configparser


class Error(Exception):

    def __init__(self, message):
        super(Error, self).__init__()
        self.message = message


class Util:

    @staticmethod
    def get_base():
        return os.path.dirname(os.path.abspath(__file__))

    @staticmethod
    def mksalt():
        alphabeth = string.ascii_letters + string.digits
        salt = "".join(random.choice(alphabeth) for x in range(0, 16))
        return "$6${}$".format(salt)

    @staticmethod
    def expand_pattern(pattern, source, name):
        if pattern is None:
            raise Error("Missing {} list".format(name))

        if pattern == "all":
            pattern = "*"

        # This works correctly for single items as well as more complex
        # cases such as explicit lists, glob patterns and any combination
        # of the above
        matches = []
        for partial_pattern in pattern.split(","):

            partial_matches = []
            for item in source:
                if fnmatch.fnmatch(item, partial_pattern):
                    partial_matches += [item]

            if not partial_matches:
                raise Error("Invalid {} list '{}'".format(name, pattern))

            matches += partial_matches

        return sorted(set(matches))


class Config:

    @staticmethod
    def _get_config_file(name):
        try:
            config_dir = os.environ["XDG_CONFIG_HOME"]
        except KeyError:
            config_dir = os.path.join(os.environ["HOME"], ".config")
        config_dir = os.path.join(config_dir, "lcitool")

        # Create the directory if it doesn't already exist
        if not os.path.exists(config_dir):
            try:
                os.mkdir(config_dir)
            except Exception as ex:
                raise Error(
                    "Can't create configuration directory ({}): {}".format(
                        config_dir, ex,
                    )
                )

        return os.path.join(config_dir, name)

    def get_flavor(self):
        flavor_file = self._get_config_file("flavor")

        try:
            with open(flavor_file, "r") as infile:
                flavor = infile.readline().strip()
        except Exception:
            # If the flavor has not been configured, we choose the default
            # and store it on disk to ensure consistent behavior from now on
            flavor = "test"
            try:
                with open(flavor_file, "w") as infile:
                    infile.write("{}\n".format(flavor))
            except Exception as ex:
                raise Error(
                    "Can't write flavor file ({}): {}".format(
                        flavor_file, ex
                    )
                )

        if flavor not in ["test", "jenkins"]:
            raise Error("Invalid flavor '{}'".format(flavor))

        return flavor

    def get_vault_password_file(self):
        vault_pass_file = None

        # The vault password is only needed for the jenkins flavor, but in
        # that case we want to make sure there's *something* in there
        if self.get_flavor() != "test":
            vault_pass_file = self._get_config_file("vault-password")

            try:
                with open(vault_pass_file, "r") as infile:
                    if not infile.readline().strip():
                        raise ValueError
            except Exception as ex:
                raise Error(
                    "Missing or invalid vault password file ({}): {}".format(
                        vault_pass_file, ex
                    )
                )

        return vault_pass_file

    def get_root_password_file(self):
        root_pass_file = self._get_config_file("root-password")

        try:
            with open(root_pass_file, "r") as infile:
                if not infile.readline().strip():
                    raise ValueError
        except Exception as ex:
            raise Error(
                "Missing or invalid root password file ({}): {}".format(
                    root_pass_file, ex
                )
            )

        return root_pass_file


class Inventory:

    def __init__(self):
        base = Util.get_base()
        ansible_cfg_path = os.path.join(base, "ansible.cfg")

        try:
            parser = configparser.SafeConfigParser()
            parser.read(ansible_cfg_path)
            inventory_path = parser.get("defaults", "inventory")
        except Exception as ex:
            raise Error(
                "Can't read inventory location in ansible.cfg: {}".format(ex))

        inventory_path = os.path.join(base, inventory_path)

        self._facts = {}
        try:
            # We can only deal with trivial inventories, but that's
            # all we need right now and we can expand support further
            # later on if necessary
            with open(inventory_path, "r") as infile:
                for line in infile:
                    host = line.strip()
                    self._facts[host] = {}
        except Exception as ex:
            raise Error(
                "Missing or invalid inventory ({}): {}".format(
                    inventory_path, ex
                )
            )

        for host in self._facts:
            try:
                self._facts[host] = self._read_all_facts(host)
                self._facts[host]["inventory_hostname"] = host
            except Exception as ex:
                raise Error("Can't load facts for '{}': {}".format(host, ex))

    @staticmethod
    def _add_facts_from_file(facts, yaml_path):
        with open(yaml_path, "r") as infile:
            some_facts = yaml.load(infile)
            for fact in some_facts:
                facts[fact] = some_facts[fact]

    def _read_all_facts(self, host):
        base = Util.get_base()

        sources = [
            os.path.join(base, "group_vars", "all"),
            os.path.join(base, "host_vars", host),
        ]

        facts = {}

        # We load from group_vars/ first and host_vars/ second, sorting
        # files alphabetically; doing so should result in our view of
        # the facts matching Ansible's
        for source in sources:
            for item in sorted(os.listdir(source)):
                yaml_path = os.path.join(source, item)
                if not os.path.isfile(yaml_path):
                    continue
                if not yaml_path.endswith(".yml"):
                    continue
                self._add_facts_from_file(facts, yaml_path)

        return facts

    def expand_pattern(self, pattern):
        return Util.expand_pattern(pattern, self._facts, "host")

    def get_facts(self, host):
        return self._facts[host]


class Projects:

    def __init__(self):
        base = Util.get_base()

        mappings_path = os.path.join(base, "vars", "mappings.yml")

        try:
            with open(mappings_path, "r") as infile:
                mappings = yaml.load(infile)
                self._mappings = mappings["mappings"]
        except Exception as ex:
            raise Error("Can't load mappings: {}".format(ex))

        source = os.path.join(base, "vars", "projects")

        self._packages = {}
        for item in os.listdir(source):
            yaml_path = os.path.join(source, item)
            if not os.path.isfile(yaml_path):
                continue
            if not yaml_path.endswith(".yml"):
                continue

            project = os.path.splitext(item)[0]

            try:
                with open(yaml_path, "r") as infile:
                    packages = yaml.load(infile)
                    self._packages[project] = packages["packages"]
            except Exception as ex:
                raise Error(
                    "Can't load packages for '{}': {}".format(project, ex))

    def expand_pattern(self, pattern):
        projects = Util.expand_pattern(pattern, self._packages, "project")

        # Some projects are internal implementation details and should
        # not be exposed to the user
        for project in ["base", "blacklist", "jenkins"]:
            if project in projects:
                projects.remove(project)

        return projects

    def get_mappings(self):
        return self._mappings

    def get_packages(self, project):
        return self._packages[project]


class Application:

    def __init__(self):
        self._config = Config()
        self._inventory = Inventory()
        self._projects = Projects()

        self._parser = argparse.ArgumentParser(
            conflict_handler="resolve",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description="libvirt CI guest management tool",
            epilog=textwrap.dedent("""
                common actions:
                  install  perform unattended host installation
                  update   prepare hosts and keep them updated
                  build    build projects on hosts

                informational actions:
                  hosts     list all known hosts
                  projects  list all known projects

                uncommon actions:
                  dockerfile  generate Dockerfile (doesn't access the host)

                glob patterns are supported for HOSTS and PROJECTS
            """),
        )
        self._parser.add_argument(
            "-a",
            metavar="ACTION",
            required=True,
            help="action to perform (see below)",
        )
        self._parser.add_argument(
            "-h",
            metavar="HOSTS",
            help="list of hosts to act on",
        )
        self._parser.add_argument(
            "-p",
            metavar="PROJECTS",
            help="list of projects to consider",
        )
        self._parser.add_argument(
            "-g",
            metavar="GIT_REVISION",
            help="git revision to build (remote/branch)",
        )

    def _execute_playbook(self, playbook, hosts, projects, git_revision):
        base = Util.get_base()

        flavor = self._config.get_flavor()
        vault_pass_file = self._config.get_vault_password_file()
        root_pass_file = self._config.get_root_password_file()

        ansible_hosts = ",".join(self._inventory.expand_pattern(hosts))
        selected_projects = self._projects.expand_pattern(projects)

        if git_revision is not None:
            tokens = git_revision.split("/")
            if len(tokens) < 2:
                raise Error(
                    "Missing or invalid git revision '{}'".format(git_revision)
                )
            git_remote = tokens[0]
            git_branch = "/".join(tokens[1:])
        else:
            git_remote = "default"
            git_branch = "master"

        ansible_cfg_path = os.path.join(base, "ansible.cfg")
        playbook_base = os.path.join(base, "playbooks", playbook)
        playbook_path = os.path.join(playbook_base, "main.yml")

        extra_vars = json.dumps({
            "base": base,
            "playbook_base": playbook_base,
            "root_password_file": root_pass_file,
            "flavor": flavor,
            "selected_projects": selected_projects,
            "git_remote": git_remote,
            "git_branch": git_branch,
        })

        cmd = [
            "ansible-playbook",
            "--limit", ansible_hosts,
            "--extra-vars", extra_vars,
        ]

        # Provide the vault password if available
        if vault_pass_file is not None:
            cmd += ["--vault-password-file", vault_pass_file]

        cmd += [playbook_path]

        # We need to point Ansible to the correct configuration file,
        # and for some reason this has to be done using the environment
        # rather than through the command line
        os.environ["ANSIBLE_CONFIG"] = ansible_cfg_path

        try:
            subprocess.check_call(cmd)
        except Exception as ex:
            raise Error(
                "Failed to run {} on '{}': {}".format(playbook, hosts, ex))

    def _action_hosts(self, _hosts, _projects, _revision):
        for host in self._inventory.expand_pattern("all"):
            print(host)

    def _action_projects(self, _hosts, _projects, _revision):
        for project in self._projects.expand_pattern("all"):
            print(project)

    def _action_install(self, hosts, _projects, _revision):
        base = Util.get_base()

        flavor = self._config.get_flavor()

        for host in self._inventory.expand_pattern(hosts):
            facts = self._inventory.get_facts(host)

            # Both memory size and disk size are stored as GiB in the
            # inventory, but virt-install expects the disk size in GiB
            # and the memory size in *MiB*, so perform conversion here
            memory_arg = str(int(facts["install_memory_size"]) * 1024)

            vcpus_arg = str(facts["install_vcpus"])

            disk_arg = "size={},pool={},bus=virtio".format(
                facts["install_disk_size"],
                facts["install_storage_pool"],
            )
            network_arg = "network={},model=virtio".format(
                facts["install_network"],
            )

            # Different operating systems require different configuration
            # files for unattended installation to work, but some operating
            # systems simply don't support unattended installation at all
            if facts["os_name"] in ["Debian", "Ubuntu"]:
                install_config = "preseed.cfg"
            elif facts["os_name"] in ["CentOS", "Fedora"]:
                install_config = "kickstart.cfg"
            else:
                raise Error(
                    "Host {} doesn't support installation".format(host)
                )
            initrd_inject = os.path.join(base, "configs", install_config)

            # preseed files must use a well-known name to be picked up by
            # d-i; for kickstart files, we can use whatever name we please
            # but we need to point anaconda in the right direction through
            # a kernel argument
            extra_arg = "console=ttyS0 ks=file:/{}".format(install_config)

            cmd = [
                "virt-install",
                "--name", host,
                "--location", facts["install_url"],
                "--virt-type", facts["install_virt_type"],
                "--arch", facts["install_arch"],
                "--machine", facts["install_machine"],
                "--cpu", facts["install_cpu_model"],
                "--vcpus", vcpus_arg,
                "--memory", memory_arg,
                "--disk", disk_arg,
                "--network", network_arg,
                "--graphics", "none",
                "--console", "pty",
                "--sound", "none",
                "--rng", "device=/dev/urandom,model=virtio",
                "--initrd-inject", initrd_inject,
                "--extra-args", extra_arg,
                "--wait", "0",
            ]

            # Only configure autostart for the guest for the jenkins flavor
            if flavor == "jenkins":
                cmd += ["--autostart"]

            try:
                subprocess.check_call(cmd)
            except Exception as ex:
                raise Error("Failed to install '{}': {}".format(host, ex))

    def _action_update(self, hosts, projects, git_revision):
        self._execute_playbook("update", hosts, projects, git_revision)

    def _action_build(self, hosts, projects, git_revision):
        self._execute_playbook("build", hosts, projects, git_revision)

    def _action_dockerfile(self, hosts, projects, _revision):
        mappings = self._projects.get_mappings()

        hosts = self._inventory.expand_pattern(hosts)
        if len(hosts) > 1:
            raise Error("Can't generate Dockerfile for multiple hosts")
        host = hosts[0]

        facts = self._inventory.get_facts(host)
        package_format = facts["package_format"]
        os_name = facts["os_name"]
        os_version = facts["os_version"]
        os_full = os_name + os_version

        if package_format not in ["deb", "rpm"]:
            raise Error("Host {} doesn't support Dockerfiles".format(host))

        projects = self._projects.expand_pattern(projects)
        for project in projects:
            if project not in facts["projects"]:
                raise Error(
                    "Host {} doesn't support project {}".format(
                        host,
                        project,
                    )
                )

        temp = {}

        # We need to add the base project manually here: the standard
        # machinery hides it because it's an implementation detail
        for project in projects + ["base"]:
            for package in self._projects.get_packages(project):
                if "default" in mappings[package]:
                    temp[package] = mappings[package]["default"]
                if package_format in mappings[package]:
                    temp[package] = mappings[package][package_format]
                if os_name in mappings[package]:
                    temp[package] = mappings[package][os_name]
                if os_full in mappings[package]:
                    temp[package] = mappings[package][os_full]

        pkgs = []
        for item in temp:
            pkgname = temp[item]
            if pkgname is None:
                continue
            if pkgname in pkgs:
                continue
            pkgs.append(pkgname)

        print("FROM {}".format(facts["docker_base"]))

        varmap = {}
        varmap["pkgs"] = " \\\n            ".join(sorted(pkgs))
        if package_format == "deb":
            sys.stdout.write(textwrap.dedent("""
                RUN export DEBIAN_FRONTEND=noninteractive && \\
                    apt-get update && \\
                    apt-get dist-upgrade -y && \\
                    apt-get install --no-install-recommends -y \\
                            {pkgs} && \\
                    apt-get autoremove -y && \\
                    apt-get autoclean -y
            """).format(**varmap))
        elif package_format == "rpm":
            if os_name == "Fedora" and os_version == "Rawhide":
                sys.stdout.write(textwrap.dedent("""
                    RUN yum update -y --nogpgcheck fedora-gpg-keys && \\
                        yum update -y && \\
                        yum install -y {pkgs} && \\
                        yum autoremove -y && \\
                        yum clean all -y
                """).format(**varmap))
            else:
                sys.stdout.write(textwrap.dedent("""
                    RUN yum update -y && \\
                        yum install -y {pkgs} && \\
                        yum autoremove -y && \\
                        yum clean all -y
                """).format(**varmap))

    def run(self):
        cmdline = self._parser.parse_args()
        action = cmdline.a
        hosts = cmdline.h
        projects = cmdline.p
        git_revision = cmdline.g

        method = "_action_{}".format(action.replace("-", "_"))

        if hasattr(self, method):
            getattr(self, method).__call__(hosts, projects, git_revision)
        else:
            raise Error("Invalid action '{}'".format(action))


if __name__ == "__main__":
    try:
        Application().run()
    except Error as err:
        sys.stderr.write("{}: {}\n".format(sys.argv[0], err.message))
        sys.exit(1)
